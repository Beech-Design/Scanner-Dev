# Beech Design Scanner Simulation
# Adrian Bowyer
# 19 February 2020

import Part, BOPTools, FreeCAD, math, copy, sys
from FreeCAD import Base

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Useful general functions and numbers

# Length in mm considered to be 0 and its square

tooShort = 0.001
tooShort2 = tooShort*tooShort

# There must be an easier way to make the FreeCAD null set...

def Null():
 n1 = Part.makeBox(1, 1, 1)
 n2 = Part.makeBox(1, 1, 1)
 n2.translate(Base.Vector(10, 10, 10))
 return(n1.common(n2))


# Make a cylinder between two points of a given radius

def Cylinder(p0, p1, r):
 p2 = p1.sub(p0)
 length = p2.Length
 if length < 0.001:
  return Null()
 c = Part.makeCylinder(r, length, p0, p2, 360)
 return c

# Make a plane cross section of FreeCAD geometry s, and return it as a list of wires
# The plane passes through point p0 and has normal n

def CrossSection(s, p0, n):
 nn = copy.deepcopy(n)
 nn.normalize()
 d = nn.dot(p0)
 wires=[]
 for i in s.slice(nn, d):
  wires.append(i)
 return wires

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Small classes for working with 2D vectors

class Point2D:
 def __init__(self, x = 0, y = 0, f = None):
  self.x = x
  self.y = y
  self.face = f

 def __repr__(self):
  return "<Point2D x:%s y:%s>" % (self.x, self.y)

 def Print(self):
  print(self.x, ',' , self.y)

 # Vector addition and subtraction

 def Add(self, p):
  result = copy.deepcopy(self)
  result.x = result.x + p.x
  result.y = result.y + p.y
  return result

 def Sub(self, p):
  result = copy.deepcopy(self)
  result.x = result.x - p.x
  result.y = result.y - p.y
  return result

 # Squared magnitude

 def Length2(self):
  return self.x*self.x + self.y*self.y

 # Multiplication by a scalar

 def Multiply(self, m):
  result = copy.deepcopy(self)
  result.x = result.x*m
  result.y = result.y*m
  return result  

 # Inner product

 def Dot(self, p):
  return self.x*p.x + self.y*p.y

 # Outer product

 def Cross(self, p):
  return self.x*p.y - self.y*p.x

# Set or change the associated face

 def SetFace(self, f):
  self.face = f

# Small class for working with 2D parametric lines
# These are defined by a start and end point.  The parameterisation
# is such that the start point has parameter = 0, and the end parameter = 1.

class Line2D:
 def __init__(self, p0 = Point2D(0, 0), p1 = Point2D(0, 0), f = None):
  self.p0 = p0
  self.direction = p1.Sub(p0)
  self.face = f
  self.empty = self.Length2() < tooShort2

 def __repr__(self):
  return "<Line2D p0:%s direction:%s>" % (self.p0, self.direction)

# The point at parameter value t

 def Point(self, t):
  p = self.direction.Multiply(t)
  return self.p0.Add(p)

 # Fine the parameter value at which another line crosses me (s) and I cross it (t)

 def Cross(self, otherLine):
  determinant = otherLine.direction.Cross(self.direction)
  if abs(determinant) < tooShort2:
   return None, None # Lines parallel
  dp = otherLine.p0.Sub(self.p0)
  s = otherLine.direction.Cross(dp)/determinant
  t = self.direction.Cross(dp)/determinant
  return s, t

 # Squared length

 def Length2(self):
  return self.direction.Length2()

# Class to hold points round the visibility polygon

#class VisibilityPoint:
# def __init__(self, point, face, d2, theta):
#  self.point = point
#  self.face = face
#  self.d2 = d2
#  self.theta = theta


#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# The main simulator class - this represents a part of the scanner.  The parts are arranged in a tree.

class ScannerPart:
 def __init__(self, offset = Base.Vector(0, 0, 0), u = Base.Vector(1, 0, 0), v = Base.Vector(0, 1, 0), w = Base.Vector(0, 0, 1), parent = None,\
  lightAngle = -1, uPixels = 0, vPixels = 0, uMM = 0, vMM = 0, focalLength = -1):

  # Offset from the parent in the parent's coordinate system
  # If the parent is None these are absolute cartesian coordinates

  self.offset = offset

  # Local Cartesian coordinates
 
  self.u = u.normalize()
  self.v = v.normalize()
  self.w = w.normalize()

  # If we are a light source (i.e. lightAngle >= 0)

  self.lightAngle = lightAngle

  # If we are a camera (i.e. focalLength >= 0)

  self.uPixels = uPixels
  self.vPixels = vPixels
  self.uMM = uMM
  self.vMM = vMM
  self.focalLength = focalLength

  # Parent and children in the tree

  self.parent = parent
  self.children = []
  if parent is not None:
   parent.children.append(self)

  # Used for lazy evaluation of position

  self.notMoved = False
  self.position = Base.Vector(0, 0, 0)

#-----------------

# Compute my absolute offset from the origin recursively
# Use lazy evaluation if I haven't moved.

 def AbsoluteOffset(self):
  if self.notMoved:
   return self.position

  if self.parent is None:
   self.position = self.offset
  else:
   parentUO = copy.deepcopy(self.parent.u)
   parentVO = copy.deepcopy(self.parent.v)
   parentWO = copy.deepcopy(self.parent.w)
   parentUO = parentUO.multiply(self.offset.x)
   parentVO = parentVO.multiply(self.offset.y)
   parentWO = parentWO.multiply(self.offset.z)
   o = parentUO.add(parentVO.add(parentWO))
   self.position = o.add(self.parent.AbsoluteOffset())
  self.notMoved = True
  return self.position

# Rotate my coordinates, and the coordinates of all my descendents recursively

 def Rotate(self, r):
  self.notMoved = False
  self.u = r.multVec(self.u).normalize()
  self.v = r.multVec(self.v).normalize()
  self.w = r.multVec(self.w).normalize()
  for child in self.children:
   child.Rotate(r)

 # Rotate about the u axis. angle is in radians

 def RotateU(self, angle):
  self.notMoved = False
  r = Base.Rotation(self.u, angle*180/math.pi)
  self.Rotate(r)

 # Rotate about the v axis. angle is in radians

 def RotateV(self, angle):
  self.notMoved = False
  r = Base.Rotation(self.v, angle*180/math.pi)
  self.Rotate(r)

 # Rotate about the w axis. angle is in radians

 def RotateW(self, angle):
  self.notMoved = False
  r = Base.Rotation(self.w, angle*180/math.pi)
  self.Rotate(r)


 # Make a picture of the tree recursively

 def Model(self):
  p1 = self.AbsoluteOffset()
  uc = Part.makeCylinder(0.2, 10, p1, self.u, 360)
  vc = Part.makeCylinder(0.2, 10, p1, self.v, 360)
  wc = Part.makeCylinder(0.2, 10, p1, self.w, 360)
  m = uc.fuse(vc)
  m = m.fuse(wc)
  if self.parent is not None:
   p0 = self.parent.AbsoluteOffset()
  else:
   p0 = Base.Vector(0, 0, 0)
  twig = Cylinder(p0, p1, 0.1)
  m = m.fuse(twig)
  for child in self.children:
   m = m.fuse(child.Model())
  return m

 # Convert a point p in the [v, w] plane into a point in absolute 3D space.

 def vwPoint(self, p):
  v = copy.deepcopy(self.v)
  v.multiply(p.x)
  w = copy.deepcopy(self.w)
  w.multiply(p.y)
  return self.AbsoluteOffset().add(v).add(w)

 def FindOtherLineAtPoint(self, p0, line0, lines):
  for line in lines:
   if line != line0:
    for a in (0, 1):
     pa = line.Point(a).Sub(p0)
     if pa.Length2() < tooShort2:
      return line
  print("FindOtherLineAtPoint - coincident line end not found!")
  return line0

 def ExtremePoint(self, p1, ray, lineWithEnds, otherLine, r, lines):
  q = 1 - r
  otherEnd1 = lineWithEnds.Point(q)
  for a in (0, 1):
   pa = otherLine.Point(a).Sub(p1)
   if pa.Length2() < tooShort2:
    b = 1 - a
    otherEnd2 = otherLine.Point(b)
    s0 = ray.direction.Cross(otherEnd1.Sub(ray.p0))
    s1 = ray.direction.Cross(otherEnd2.Sub(ray.p0))
    sign = s0*s1
    if sign <= 0:
     return 0
    return s0
  print("ExtremePoint - other line does not touch original line!")
  return 0
      

 def RayCheck(self, visibilityPolygon, p0, lineWithEnds, r, lines):
  p1 = lineWithEnds.Point(r)
  otherLine = self.FindOtherLineAtPoint(p1, lineWithEnds, lines)
  ray = Line2D(p0, p1)
  minS = 1
  minFace = lineWithEnds.face
  minBehind = sys.float_info.max
  behindFace = None
  for line1 in lines:
   if line1 != lineWithEnds and line1 != otherLine:
    s, t = ray.Cross(line1)
    if s != None:
     if t >= 0 and t <= 1:
      if s > 0:
       if s < minBehind:
        minBehind = s
        behindFace = line1.face
       if s < minS:
        minS = s
        minFace = line1.face
  classification = 0
  if (abs(minS - 1) < tooShort) and (behindFace != None):
   classification = self.ExtremePoint(p1, ray, lineWithEnds, otherLine, r, lines)
  if classification > 0:
   p2 = ray.Point(minBehind)
   p2.SetFace(behindFace)
   visibilityPolygon.append(p2)
   p3 = ray.Point(minS)
   p3.SetFace(minFace)
   visibilityPolygon.append(p3)
  elif classification == 0:
   p2 = ray.Point(minS)
   p2.SetFace(minFace)
   visibilityPolygon.append(p2)
  else:     
   p2 = ray.Point(minS)
   p2.SetFace(minFace)
   visibilityPolygon.append(p2)
   p3 = ray.Point(minBehind)
   p3.SetFace(behindFace)
   visibilityPolygon.append(p3)
 
 def PointIsInAFace(self, p, faces):
  v = Part.Vertex(p)
  for face in faces:
   if face.distToShape(v)[0] < tooShort:
    return True
  return False

 def PlotPolygon(self, polygon):
  wire = []
  for p in polygon: 
   p3D = self.vwPoint(p)
   wire.append(p3D)
  if len(wire) >= 2:
   Part.show(Part.makePolygon(wire))

 def PlotLine(self, line):
  p0 = line.Point(0)
  p03 = self.vwPoint(p0)
  p1 = line.Point(1)
  p13 = self.vwPoint(p1)
  Part.show(Part.makePolygon([p03, p13]))

 def MakeWiresIncludingFacelessOnes(self, anglePairs, faces):
  wires = []
  wire = []
  for i in range(0, len(anglePairs)):
   pair = anglePairs[i] 
   p3D = self.vwPoint(pair[1])
   wire.append(p3D)
  if len(wire) >= 2:
   wires.append(Part.makePolygon(wire))
  return wires
 

 def MakeWires(self, anglePairs, faces):
  wires = []
  wire = []
  pair1 = anglePairs[0] 
  p3D1 = self.vwPoint(pair1[1])
  wire.append(p3D1)
  for i in range(1, len(anglePairs)):
   pair2 = anglePairs[i] 
   p3D2 = self.vwPoint(pair2[1])
   halfWayPoint = copy.deepcopy(p3D1)
   halfWayPoint = halfWayPoint.add(p3D2)
   halfWayPoint.multiply(0.5)
   if self.PointIsInAFace(halfWayPoint, faces):
    wire.append(p3D2)
   else:
    if len(wire) >= 2:
     wires.append(Part.makePolygon(wire))
    wire = []
    wire.append(p3D2)
   pair1 = pair2
   p3D1 = p3D2
  if len(wire) >= 2:
   wires.append(Part.makePolygon(wire))
  return wires

 def SortByAngle(self, visibiltyPolygon):
  anglePairs = []
  for p in visibiltyPolygon:
   line = Line2D(Point2D(0, 0), p)
   angle = math.atan2(line.direction.y, line.direction.x)
   anglePairs.append((angle, p))
  anglePairs.sort(key=lambda pair: pair[0])

 # Remove duplicates (note separate points may share
 # the same angle, so we use inter-point distance).

  oldPair = anglePairs[0]
  newAnglePairs = []
  newAnglePairs.append(oldPair)
  for pair in anglePairs:
   diff = pair[1].Sub(oldPair[1])
   d2 = diff.Length2()
   if d2 > tooShort2:
    newAnglePairs.append(pair)
    oldPair = pair
  return newAnglePairs  

 # Turn on the light and make a cross section of a shape, s.
 # Then compute its visibility polygon in the 2D plane of the light
 # sheet (the [v, w] plane) and return that as a FreeCAD object in 3D.
 # (See: https://en.wikipedia.org/wiki/Visibility_polygon)

 def GetVisibilityPolygons(self, s):
  p0 = self.AbsoluteOffset()
  x0 = self.v.dot(p0)
  y0 = self.w.dot(p0)
  lines = []
  visibilityPolygon = []

 # We have to visit each face of object s in turn and compute the line of
 # intersection of the light sheet plane with it because the FreeCAD CrossSection
 # function for whole objects creates internal triangulations in cross-section polygons,
 # which we don't want.

  faces = s.Faces
  for face in faces:

   # Where does the plane cut the face. Note that line may have
   # more than one section.

   faceLines = CrossSection(face, p0, self.u)

   for line in faceLines:
    vertexes = line.Vertexes
    if len(vertexes) != 2:
     print("Line without 2 ends!", len(vertexes))
    else:

    # Find the projection of line into the light sheet plane.
    # The projection of the light source point is the origin
    # of coordinates.

     va = vertexes[0]
     vb = vertexes[1]

     xa = self.v.dot(va.Point) - x0
     ya = self.w.dot(va.Point) - y0
     pa = Point2D(xa, ya, face)

     xb = self.v.dot(vb.Point) - x0
     yb = self.w.dot(vb.Point) - y0
     pb = Point2D(xb, yb, face)

     line = Line2D(pa, pb, face)
     lines.append(line)

  for lineWithEnds in lines:
   self.RayCheck(visibilityPolygon, Point2D(0, 0), lineWithEnds, 0, lines)
   self.RayCheck(visibilityPolygon, Point2D(0, 0), lineWithEnds, 1, lines)
  anglePairs = self.SortByAngle(visibilityPolygon)
#  edges = self.MakeWiresIncludingFacelessOnes(anglePairs, faces)
  edges = self.MakeWires(anglePairs, faces)     
  return edges

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Testing, testing...

a = Part.makeBox(10, 4, 15)
a.translate(Base.Vector(0, 3, 0))
b = Part.makeBox(10, 8, 30)
c =  Part.makeBox(10, 8, 30)
c.translate(Base.Vector(0, 16, 0))
b = b.fuse(c)
b = b.cut(a)
#b = a.cut(b)
Part.show(b)
world = ScannerPart()
twig1 = ScannerPart(offset = Base.Vector(18, 20, 15), parent = world)
twig1.RotateV(1) #math.pi/2)
wires = twig1.GetVisibilityPolygons(b)
for wire in wires:
 Part.show(wire)
#Part.show(c)
Part.show(world.Model())

#world = ScannerPart()
#twig1 = ScannerPart(offset = Base.Vector(8, 20, 25), parent = world)
#twig2 = ScannerPart(offset = Base.Vector(10, -5, 6), parent = world)
#twig3 = ScannerPart(offset = Base.Vector(-10, 10, 30), parent = twig1)
#twig1.RotateU(1)
#a = world.Model()
#Part.show(a)


