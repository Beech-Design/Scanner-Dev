# Beech Design Scanner Simulation
# Adrian Bowyer
# 19 February 2020

import Part, BOPTools, FreeCAD, math, copy, sys
from FreeCAD import Base
import PySide
from PySide import QtGui, QtCore

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Useful general functions and numbers
# -----------------------------------------------

# Length in mm considered to be 0 and its square

veryShort = 0.001
veryShort2 = veryShort*veryShort

# Roughly the largest dimension in mm of anything that will be dealt with

veryLong = 80

# There must be an easier way to make the FreeCAD null set...

def Null():
 n1 = Part.makeBox(1, 1, 1)
 n2 = Part.makeBox(1, 1, 1)
 n2.translate(Base.Vector(10, 10, 10))
 return(n1.common(n2))


# Make a cylinder between two points of a given radius

def Cylinder(p0, p1, r):
 p2 = p1.sub(p0)
 length = p2.Length
 if length < 0.001:
  return Null()
 c = Part.makeCylinder(r, length, p0, p2, 360)
 return c

# Make a plane cross section of FreeCAD geometry s, and return it as a list of wires
# The plane passes through point p0 and has normal n

def CrossSection(s, p0, n):
 nn = copy.deepcopy(n)
 nn.normalize()
 d = nn.dot(p0)
 wires=[]
 for i in s.slice(nn, d):
  wires.append(i)
 return wires

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Small classes for working with 2D vectors
# -----------------------------------------------------

class Point2D:
 def __init__(self, x = 0, y = 0, f = None):
  self.x = x
  self.y = y
  self.face = f

 def __repr__(self):
  return "<Point2D x:%s y:%s>" % (self.x, self.y)

 def Print(self):
  print(self.x, ',' , self.y)

 # Vector addition and subtraction

 def Add(self, p):
  result = copy.deepcopy(self)
  result.x = result.x + p.x
  result.y = result.y + p.y
  return result

 def Sub(self, p):
  result = copy.deepcopy(self)
  result.x = result.x - p.x
  result.y = result.y - p.y
  return result

 # Squared magnitude

 def Length2(self):
  return self.x*self.x + self.y*self.y

 # Multiplication by a scalar

 def Multiply(self, m):
  result = copy.deepcopy(self)
  result.x = result.x*m
  result.y = result.y*m
  return result  

 # Inner product

 def Dot(self, p):
  return self.x*p.x + self.y*p.y

 # Outer product

 def Cross(self, p):
  return self.x*p.y - self.y*p.x

# Set or change the associated face

 def SetFace(self, f):
  self.face = f

#------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Small class for working with 2D parametric lines
# --------------------------------------------------------------


# Lines are defined by a start and end point.  The parameterisation
# is such that the start point has parameter = 0, and the end parameter = 1.

class Line2D:
 def __init__(self, p0 = Point2D(0, 0), p1 = Point2D(0, 0), f = None):
  self.p0 = p0
  self.direction = p1.Sub(p0)
  self.face = f
  self.empty = self.Length2() < veryShort2

 def __repr__(self):
  return "<Line2D p0:%s direction:%s>" % (self.p0, self.direction)

# The point at parameter value t

 def Point(self, t):
  p = self.direction.Multiply(t)
  return self.p0.Add(p)

 # Fine the parameter value at which another line crosses me (s) and I cross it (t)

 def Cross(self, otherLine):
  determinant = otherLine.direction.Cross(self.direction)
  if abs(determinant) < veryShort2:
   return None, None # Lines parallel
  dp = otherLine.p0.Sub(self.p0)
  s = otherLine.direction.Cross(dp)/determinant
  t = self.direction.Cross(dp)/determinant
  return s, t

 # Squared length

 def Length2(self):
  return self.direction.Length2()

#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 2D functions for dealing with visibility polygons for the light sheet.
# --------------------------------------------------------------------------------------

# The light sheet hits everything to be scanned in a slicing plane.  But not everything
# the slice cuts will be illuminated; some will be in shadow.  This deals with what
# the light source can see, and therefore what it actually illuminates.

# Each line in the section polygon should join to another as the polygon
# is a section through a solid.  Find the other line.

def FindOtherLineAtPoint(p0, line0, lines):
 for line in lines:
  if line is not line0:
   for a in (0, 1):
    pa = line.Point(a).Sub(p0)
    if pa.Length2() < veryShort2:
     return line
 print("FindOtherLineAtPoint - coincident line end not found!")
 return line0

# A ray through a polygon vertex can go into solid, or it can
# just kiss the vertex and carry on in space. This categorises
# that situation.

def ExtremePoint(p1, ray, lineWithEnds, otherLine, r, lines):
 q = 1 - r
 otherEnd1 = lineWithEnds.Point(q)
 for a in (0, 1):
  pa = otherLine.Point(a).Sub(p1)
  if pa.Length2() < veryShort2:
   b = 1 - a
   otherEnd2 = otherLine.Point(b)
   s0 = ray.direction.Cross(otherEnd1.Sub(ray.p0))
   s1 = ray.direction.Cross(otherEnd2.Sub(ray.p0))
   sign = s0*s1
   if sign <= 0:
    return 0
   return s0
 print("ExtremePoint - other line does not touch original line!")
 return 0


# Find out if p is in a face of the 3D model

def PointIsInAFace(p, faces):
 v = Part.Vertex(p)
 for face in faces:
  if face.distToShape(v)[0] < veryShort:
   return face
 return None

# We have a set of points on the visible polygon in 2D, sorted by angle.
# Add lines between them in 3D that are in actual faces to output, together.
# with their face.  Join contiguous lines that share a face.
# This actually works in 3D, as we need a 3D result.  But all the logic
# is 2D because we know all the points lie in a plane.

def Make3DPolygons(anglePairs, faces, lightSource):

# Make a list of all the 3D points and which faces (if any) the lines
# between them lie in.

 allPolygons = []
 pair1 = anglePairs[0] 
 p3D1 = lightSource.vwPoint(pair1[1])
 allPolygons.append((p3D1, None))
 for i in range(1, len(anglePairs)):
  pair2 = anglePairs[i] 
  p3D2 = lightSource.vwPoint(pair2[1])
  halfWayPoint = copy.deepcopy(p3D1)
  halfWayPoint = halfWayPoint.add(p3D2)
  halfWayPoint.multiply(0.5)
  face = PointIsInAFace(halfWayPoint, faces)
  allPolygons.append((p3D2, face))
  p3D1 = p3D2

# Go through and split the list at lines in free space that so have face set to None

  polygon = []
  polygons = []
  pair1 = allPolygons[0]
  polygon.append(pair1)
  for i in range (1, len(allPolygons)):
   pair2 = allPolygons[i]
   if pair2[1] is not None:
     polygon.append(pair2)
   else:
    if len(polygon) >= 2:
     polygons.append(polygon)
    polygon = []
    polygon.append(pair2)
   pair1 = pair2
  if len(polygon) >= 2:
   polygons.append(polygon)

# Now correct the faces of points with faces still set to None

 for polygon in polygons:
  for i in range(1, len(polygon)):
   newPair = (polygon[i-1][0], polygon[i][1])
   polygon[i-1] = newPair

# Now remove points internal to faces, just leaving those at the coreners or ends.

 for k in range(0, len(polygons)):
  polygon = polygons[k]
  newPolygon = []
  newPolygon.append(polygon[0])
  for i in range(1, len(polygon) - 1):
   if polygon[i-1][1] is not polygon[i][1]:
    newPolygon.append(polygon[i])
  newPolygon.append(polygon[len(polygon) - 1])
  polygons[k] = newPolygon

 return polygons

# Plot the 3D polygons (mainly for checking; not actually 2D but 3D...)

def PlotPolygons(polygons):
 for polygon in polygons:
  wire = []
  for pair in polygon:
   wire.append(pair[0])
  Part.show(Part.makePolygon(wire))

# We have the visibility polygon, but it is in random order. Sort the points
# by swept angle from the origin (which is where the light is).

def SortByAngle(visibiltyPolygon, lightSource):
 anglePairs = []
 for p in visibiltyPolygon:
  line = Line2D(Point2D(0, 0), p)
  angle = math.atan2(line.direction.y, line.direction.x)
  if angle < 0:
   angle = angle + 2*math.pi   # atan2's returns angles in [-pi, pi]. Fix that so they sort right
  anglePairs.append((angle, p))
 anglePairs.sort(key=lambda pair: pair[0])

# Remove duplicates (note separate points may share
# the same angle, so we use inter-point distance to discriminate).
# We also convert the angles back into [-pi, pi].

 oldPair = anglePairs[0]
 newAnglePairs = []
 newAnglePairs.append(oldPair)
 for pair in anglePairs:
  diff = pair[1].Sub(oldPair[1])
  d2 = diff.Length2()
  if d2 > veryShort2:
   if pair[0] > math.pi:
    newPair = (pair[0] - 2*math.pi, pair[1])
    pair = newPair
   newAnglePairs.append(pair)
   oldPair = pair

# Eliminate everything outside the angle of the light sheet

 anglePairs = []
 inside = False
 halfAngle = 0.5*lightSource.lightAngle
 for i in range (0, len(newAnglePairs)):
  pair = newAnglePairs[i]
  newInside = False
  if pair[0] > -halfAngle:
    if not inside and i is not 0:
     previous = newAnglePairs[i-1]
     polygonLine = Line2D(previous[1], pair[1])
     lightEdgeLine = Line2D(Point2D(0, 0), Point2D(math.cos(-halfAngle), math.sin(-halfAngle)))
     s, t = polygonLine.Cross(lightEdgeLine)
     if s < 0 or s > 1:
      print("SortByAngle - negative light edge not in line segment, parameter: ", s)
     anglePairs.append((-halfAngle, polygonLine.Point(s)))
     newInside = True
  if pair[0] > halfAngle:
   if inside and i is not 0:
    previous = newAnglePairs[i-1]
    polygonLine = Line2D(previous[1], pair[1])
    lightEdgeLine = Line2D(Point2D(0, 0), Point2D(math.cos(halfAngle), math.sin(halfAngle)))
    s, t = polygonLine.Cross(lightEdgeLine)
    if s < 0 or s > 1:
     print("SortByAngle - positive light edge not in line segment, parameter: ", s)
    anglePairs.append((halfAngle, polygonLine.Point(s)))
    newInside = False
  else:
   anglePairs.append(pair)
  inside = newInside   
  
 return anglePairs

 #return newAnglePairs  
     
# Cast rays from the origin (where the light is) through the points lineWithEnds(r), find
# what they hit, add that to the output polygon, sort that into angle order, then
# convert it back to 3D.  Almost all this function and the functions it calls work
# in 2D except for the very last line.

def RayCast(lines, faces, lightSource):
 visibilityPolygon = []
 for lineWithEnds in lines:
  for r in (0, 1): 
   p1 = lineWithEnds.Point(r)

 # Find the other line at this point

   otherLine = FindOtherLineAtPoint(p1, lineWithEnds, lines)
   ray = Line2D(Point2D(0, 0), p1)

 # s is the ray's parameter. We need to know the closest hit to 
 # p0, and possibly (if that is a projecting vertex) the point hit
 # behind that.

   minS = 1
   minFace = lineWithEnds.face
   minBehind = sys.float_info.max
   behindFace = None
   for line1 in lines:
    if line1 is not lineWithEnds and line1 is not otherLine:
     s, t = ray.Cross(line1)
     if s is not None:
      if t >= 0 and t <= 1:
       if s > 0:
        if s < minBehind:
         minBehind = s
         behindFace = line1.face
        if s < minS:
         minS = s
         minFace = line1.face
   classification = 0
   if (abs(minS - 1) < veryShort) and (behindFace is not None):
    classification = ExtremePoint(p1, ray, lineWithEnds, otherLine, r, lines)
   if classification > 0:
    p2 = ray.Point(minBehind)
    p2.SetFace(behindFace)
    visibilityPolygon.append(p2)
    p3 = ray.Point(minS)
    p3.SetFace(minFace)
    visibilityPolygon.append(p3)
   elif classification is 0:
    p2 = ray.Point(minS)
    p2.SetFace(minFace)
    visibilityPolygon.append(p2)
   else:     
    p2 = ray.Point(minS)
    p2.SetFace(minFace)
    visibilityPolygon.append(p2)
    p3 = ray.Point(minBehind)
    p3.SetFace(behindFace)
    visibilityPolygon.append(p3)
 anglePairs = SortByAngle(visibilityPolygon, lightSource)
 return Make3DPolygons(anglePairs, faces, lightSource) 

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# The main simulator class - this represents a part of the scanner.  The parts are arranged in a tree.
# ------------------------------------------------------------------------------------------------------------------------------

class ScannerPart:
 def __init__(self, offset = Base.Vector(0, 0, 0), u = Base.Vector(1, 0, 0), v = Base.Vector(0, 1, 0), w = Base.Vector(0, 0, 1), parent = None,\
  lightAngle = -1, uPixels = 0, vPixels = 0, uMM = 0, vMM = 0, focalLength = -1):

  # Offset from the parent in the parent's coordinate system
  # If the parent is None these are absolute cartesian coordinates

  self.offset = offset

  # Local Cartesian coordinates
 
  self.u = u.normalize()
  self.v = v.normalize()
  self.w = w.normalize()

  # If we are a light source (i.e. lightAngle >= 0)

  if lightAngle > math.pi:
   print("Light source with angle > pi: ", lightAngle)

  self.lightAngle = lightAngle

  # If we are a camera (i.e. focalLength >= 0)

  self.uPixels = uPixels
  self.vPixels = vPixels
  self.uMM = uMM
  self.vMM = vMM
  self.focalLength = focalLength

  # Parent and children in the tree

  self.parent = parent
  self.children = []
  if parent is not None:
   parent.children.append(self)

  # Used for lazy evaluation of position

  self.notMoved = False
  self.position = Base.Vector(0, 0, 0)

#-----------------

# Compute my absolute offset from the origin recursively
# Use lazy evaluation if I haven't moved.

 def AbsoluteOffset(self):
  if self.notMoved:
   return self.position

  if self.parent is None:
   self.position = self.offset
  else:
   parentUO = copy.deepcopy(self.parent.u)
   parentVO = copy.deepcopy(self.parent.v)
   parentWO = copy.deepcopy(self.parent.w)
   parentUO = parentUO.multiply(self.offset.x)
   parentVO = parentVO.multiply(self.offset.y)
   parentWO = parentWO.multiply(self.offset.z)
   o = parentUO.add(parentVO.add(parentWO))
   self.position = o.add(self.parent.AbsoluteOffset())
  self.notMoved = True
  return self.position

# Rotate my coordinates, and the coordinates of all my descendents recursively

 def Rotate(self, r):
  self.notMoved = False
  self.u = r.multVec(self.u).normalize()
  self.v = r.multVec(self.v).normalize()
  self.w = r.multVec(self.w).normalize()
  for child in self.children:
   child.Rotate(r)

 # Rotate about the u axis. angle is in radians

 def RotateU(self, angle):
  self.notMoved = False
  r = Base.Rotation(self.u, angle*180/math.pi)
  self.Rotate(r)

 # Rotate about the v axis. angle is in radians

 def RotateV(self, angle):
  self.notMoved = False
  r = Base.Rotation(self.v, angle*180/math.pi)
  self.Rotate(r)

 # Rotate about the w axis. angle is in radians

 def RotateW(self, angle):
  self.notMoved = False
  r = Base.Rotation(self.w, angle*180/math.pi)
  self.Rotate(r)


 # Make a solid model of the tree recursively so we can plot it to check
 # what we've got.

 def Model(self):
  p1 = self.AbsoluteOffset()
  uc = Part.makeCylinder(0.2, 5, p1, self.u, 360)
  vc = Part.makeCylinder(0.2, 5, p1, self.v, 360)
  wc = Part.makeCylinder(0.2, 5, p1, self.w, 360)
  if self.lightAngle > 0:
   vv = copy.deepcopy(self.v)
   ww = copy.deepcopy(self.w)
   vv.multiply(veryLong*math.sin(self.lightAngle*0.5))
   ww.multiply(veryLong*math.cos(self.lightAngle*0.5))
   p2 = p1.add(vv).add(ww)
   p3 = p1.sub(vv).add(ww)
   e1 = Part.makeLine(p1, p2)
   e2 = Part.makeLine(p2, p3)
   e3 = Part.makeLine(p3, p1)
   Part.show(Part.Wire([e1,e2,e3]))
  m = uc.fuse(vc)
  m = m.fuse(wc)
  if self.parent is not None:
   p0 = self.parent.AbsoluteOffset()
  else:
   p0 = Base.Vector(0, 0, 0)
  twig = Cylinder(p0, p1, 0.1)
  m = m.fuse(twig)
  for child in self.children:
   m = m.fuse(child.Model())
  return m

 # Convert a point p in the [v, w] plane into a point in absolute 3D space.
 # The [v, w] plane is the light sheet for a light source.  Remember that
 # w is the plane's x axis because w is the centre of the beam.  
 # This and the next function are for the light sheet simulation.

 def vwPoint(self, p):
  w = copy.deepcopy(self.w)
  w.multiply(p.x)
  v = copy.deepcopy(self.v)
  v.multiply(p.y)
  return self.AbsoluteOffset().add(v).add(w)

 # Project a 3D point into the [v, w] plane.  Again w is the x axis.

 def xyPoint(self, p3D):
  x = self.w.dot(p3D)
  y = self.v.dot(p3D)
  p = Point2D(x, y)
  return p

 # Convert a point p in the [u, v] plane into a point in absolute 3D space.
 # The [u, v] plane is the focal plane of a camera, which points along the
 # w axis.  The lens (or pinhole) is self.focalLength along w.  

 def uvPoint(self, p):
  u = copy.deepcopy(self.u)
  u.multiply(p.x)
  v = copy.deepcopy(self.v)
  v.multiply(p.y)
  return self.AbsoluteOffset().add(u).add(v)


 # If we are a light source...
 # Turn on the light and make a cross section of a shape, s.
 # Then compute its visibility polygon in the 2D plane of the light
 # sheet (the [v, w] plane) and return that as a FreeCAD object in 3D.
 # (See: https://en.wikipedia.org/wiki/Visibility_polygon)

 def GetVisibilityPolygons(self, s):
  if self.lightAngle <= 0:
   print("Illuminated polygon requested for non light source.")

  # The origin of coordinates in the 2D light sheet (x0, y0) is the projection of the position
  # of the light source in 3D into the light source's [v, w] plane.  We use (x, y) for
  # coordinates in the plane to avoid confuusion with the u, v, and w vectors.

  p0 = self.AbsoluteOffset()

  origin2D = self.xyPoint(p0)
  lines = []

 # We have to visit each face of object s in turn and compute the line of
 # intersection of the light sheet plane with it because the FreeCAD CrossSection
 # function for whole objects creates internal triangulations in cross-section polygons,
 # which we don't want.

  faces = s.Faces
  for face in faces:

   # Where does the plane cut the face. Note that line may have
   # more than one section if the face has a hole in it.

   faceLines = CrossSection(face, p0, self.u)

   for line in faceLines:
    vertexes = line.Vertexes
    if len(vertexes) is not 2:
     print("Line without 2 ends!", len(vertexes))
    else:

    # Find the projection of line into the light sheet plane.
    # The projection of the light source point is the origin
    # of coordinates.

    # We keep track of the face each line came from, though (perhaps surprisingly)
    # that is not much use.

     v2D0 = self.xyPoint(vertexes[0].Point).Sub(origin2D)
     v2D1 = self.xyPoint(vertexes[1].Point).Sub(origin2D)     

     line = Line2D(v2D0, v2D1, face)
     lines.append(line)

  # Cast a ray from the light source through each line end in turn and add what it hits
  # to the visibility polygons.  Process those polygons back into 3D.

  return RayCast(lines, faces, self)

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Testing, testing...

#clearing previous messages
mw=Gui.getMainWindow()
c=mw.findChild(QtGui.QPlainTextEdit, "Python console")
c.clear()
r=mw.findChild(QtGui.QTextEdit, "Report view")
r.clear()

a = Part.makeBox(10, 4, 15)
a.translate(Base.Vector(0, 3, 0))
b = Part.makeBox(10, 8, 30)
c =  Part.makeBox(10, 8, 30)
c.translate(Base.Vector(0, 16, 0))
b = b.fuse(c)
b = b.cut(a)
#b = a.cut(b)
Part.show(b)
world = ScannerPart()
lightSource = ScannerPart(offset = Base.Vector(18, 20, 15), parent = world, lightAngle = 2)
lightSource.RotateV(math.pi - 1) #math.pi/2)
polygons = lightSource.GetVisibilityPolygons(b)
PlotPolygons(polygons)
Part.show(world.Model())

#world = ScannerPart()
#twig1 = ScannerPart(offset = Base.Vector(8, 20, 25), parent = world)
#twig2 = ScannerPart(offset = Base.Vector(10, -5, 6), parent = world)
#twig3 = ScannerPart(offset = Base.Vector(-10, 10, 30), parent = twig1)
#twig1.RotateU(1)
#a = world.Model()
#Part.show(a)


