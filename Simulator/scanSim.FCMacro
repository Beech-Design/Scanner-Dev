# Beech Design Scanner Simulation
# Adrian Bowyer
# 19 February 2020

import Part, BOPTools, FreeCAD, math, copy, sys
from FreeCAD import Base

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Useful general functions and numbers

# Length in mm considered to be 0 and its square

tooShort = 0.001
tooShort2 = tooShort*tooShort

# There must be an easier way to make the FreeCAD null set...

def Null():
 n1 = Part.makeBox(1, 1, 1)
 n2 = Part.makeBox(1, 1, 1)
 n2.translate(Base.Vector(10, 10, 10))
 return(n1.common(n2))


# Make a cylinder between two points of a given radius

def Cylinder(p0, p1, r):
 p2 = p1.sub(p0)
 length = p2.Length
 if length < 0.001:
  return Null()
 c = Part.makeCylinder(r, length, p0, p2, 360)
 return c

# Make a plane cross section of FreeCAD geometry s, and return it as a list of wires
# The plane passes through point p0 and has normal n

def CrossSection(s, p0, n):
 nn = copy.deepcopy(n)
 nn.normalize()
 d = nn.dot(p0)
 wires=[]
 for i in s.slice(nn, d):
  wires.append(i)
 return wires

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Small classes for working with 2D vectors

class Point2D:
 def __init__(self, x = 0, y = 0, f = None):
  self.x = x
  self.y = y
  self.face = f

 def __repr__(self):
  return "<Point2D x:%s y:%s>" % (self.x, self.y)

 def Print(self):
  print(self.x, ',' , self.y)

 # Vector addition and subtraction

 def Add(self, p):
  result = copy.deepcopy(self)
  result.x = result.x + p.x
  result.y = result.y + p.y
  return result

 def Sub(self, p):
  result = copy.deepcopy(self)
  result.x = result.x - p.x
  result.y = result.y - p.y
  return result

 # Squared magnitude

 def Length2(self):
  return self.x*self.x + self.y*self.y

 # Multiplication by a scalar

 def Multiply(self, m):
  result = copy.deepcopy(self)
  result.x = result.x*m
  result.y = result.y*m
  return result  

 # Inner product

 def Dot(self, p):
  return self.x*p.x + self.y*p.y

 # Outer product

 def Cross(self, p):
  return self.x*p.y - self.y*p.x

# Set or change the associated face

 def SetFace(self, f):
  self.face = f

# Small class for working with 2D parametric lines
# These are defined by a start and end point.  The parameterisation
# is such that the start point has parameter = 0, and the end parameter = 1.

class Line2D:
 def __init__(self, p0 = Point2D(0, 0), p1 = Point2D(0, 0), f = None):
  self.p0 = p0
  self.direction = p1.Sub(p0)
  self.face = f
  self.empty = self.Length2() < tooShort2

 def __repr__(self):
  return "<Line2D p0:%s direction:%s>" % (self.p0, self.direction)

# The point at parameter value t

 def Point(self, t):
  p = self.direction.Multiply(t)
  return self.p0.Add(p)

 # Fine the parameter value at which another line crosses me (s) and I cross it (t)

 def Cross(self, otherLine):
  determinant = otherLine.direction.Cross(self.direction)
  if abs(determinant) < tooShort2:
   return None, None # Lines parallel
  dp = otherLine.p0.Sub(self.p0)
  s = otherLine.direction.Cross(dp)/determinant
  t = self.direction.Cross(dp)/determinant
  return s, t

 # Squared length

 def Length2(self):
  return self.direction.Length2()



#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# The main simulator class - this represents a part of the scanner.  The parts are arranged in a tree.

class ScannerPart:
 def __init__(self, offset = Base.Vector(0, 0, 0), u = Base.Vector(1, 0, 0), v = Base.Vector(0, 1, 0), w = Base.Vector(0, 0, 1), parent = None,\
  lightAngle = -1, uPixels = 0, vPixels = 0, uMM = 0, vMM = 0, focalLength = -1):

  # Offset from the parent in the parent's coordinate system
  # If the parent is None these are absolute cartesian coordinates

  self.offset = offset

  # Local Cartesian coordinates
 
  self.u = u.normalize()
  self.v = v.normalize()
  self.w = w.normalize()

  # If we are a light source (i.e. lightAngle >= 0)

  self.lightAngle = lightAngle

  # If we are a camera (i.e. focalLength >= 0)

  self.uPixels = uPixels
  self.vPixels = vPixels
  self.uMM = uMM
  self.vMM = vMM
  self.focalLength = focalLength

  # Parent and children in the tree

  self.parent = parent
  self.children = []
  if parent is not None:
   parent.children.append(self)

  # Used for lazy evaluation of position

  self.notMoved = False
  self.position = Base.Vector(0, 0, 0)

#-----------------

# Compute my absolute offset from the origin recursively
# Use lazy evaluation if I haven't moved.

 def AbsoluteOffset(self):
  if self.notMoved:
   return self.position

  if self.parent is None:
   self.position = self.offset
  else:
   parentUO = copy.deepcopy(self.parent.u)
   parentVO = copy.deepcopy(self.parent.v)
   parentWO = copy.deepcopy(self.parent.w)
   parentUO = parentUO.multiply(self.offset.x)
   parentVO = parentVO.multiply(self.offset.y)
   parentWO = parentWO.multiply(self.offset.z)
   o = parentUO.add(parentVO.add(parentWO))
   self.position = o.add(self.parent.AbsoluteOffset())
  self.notMoved = True
  return self.position

# Rotate my coordinates, and the coordinates of all my descendents recursively

 def Rotate(self, r):
  self.notMoved = False
  self.u = r.multVec(self.u).normalize()
  self.v = r.multVec(self.v).normalize()
  self.w = r.multVec(self.w).normalize()
  for child in self.children:
   child.Rotate(r)

 # Rotate about the u axis. angle is in radians

 def RotateU(self, angle):
  self.notMoved = False
  r = Base.Rotation(self.u, angle*180/math.pi)
  self.Rotate(r)

 # Rotate about the v axis. angle is in radians

 def RotateV(self, angle):
  self.notMoved = False
  r = Base.Rotation(self.v, angle*180/math.pi)
  self.Rotate(r)

 # Rotate about the w axis. angle is in radians

 def RotateW(self, angle):
  self.notMoved = False
  r = Base.Rotation(self.w, angle*180/math.pi)
  self.Rotate(r)


 # Make a solid model of the tree recursively

 def Model(self):
  p1 = self.AbsoluteOffset()
  uc = Part.makeCylinder(0.2, 10, p1, self.u, 360)
  vc = Part.makeCylinder(0.2, 10, p1, self.v, 360)
  wc = Part.makeCylinder(0.2, 10, p1, self.w, 360)
  m = uc.fuse(vc)
  m = m.fuse(wc)
  if self.parent is not None:
   p0 = self.parent.AbsoluteOffset()
  else:
   p0 = Base.Vector(0, 0, 0)
  twig = Cylinder(p0, p1, 0.1)
  m = m.fuse(twig)
  for child in self.children:
   m = m.fuse(child.Model())
  return m

 # Convert a point p in the [v, w] plane into a point in absolute 3D space.

 def vwPoint(self, p):
  v = copy.deepcopy(self.v)
  v.multiply(p.x)
  w = copy.deepcopy(self.w)
  w.multiply(p.y)
  return self.AbsoluteOffset().add(v).add(w)

 # Each line in the section polygon should join to another as the polygon
 # is a section through a solid.  Find the other line.

 def FindOtherLineAtPoint(self, p0, line0, lines):
  for line in lines:
   if line != line0:
    for a in (0, 1):
     pa = line.Point(a).Sub(p0)
     if pa.Length2() < tooShort2:
      return line
  print("FindOtherLineAtPoint - coincident line end not found!")
  return line0

 # A ray through a polygon vertex can go into solid, or it can
 # just kiss the vertex and carry on in space. This categorises
 # that situation.

 def ExtremePoint(self, p1, ray, lineWithEnds, otherLine, r, lines):
  q = 1 - r
  otherEnd1 = lineWithEnds.Point(q)
  for a in (0, 1):
   pa = otherLine.Point(a).Sub(p1)
   if pa.Length2() < tooShort2:
    b = 1 - a
    otherEnd2 = otherLine.Point(b)
    s0 = ray.direction.Cross(otherEnd1.Sub(ray.p0))
    s1 = ray.direction.Cross(otherEnd2.Sub(ray.p0))
    sign = s0*s1
    if sign <= 0:
     return 0
    return s0
  print("ExtremePoint - other line does not touch original line!")
  return 0
      
 # Cast rays from the origin (where the light is) through the points lineWithEnds(r), find
 # what they hit, add that to the output polygon, sort that into angle order, then
 # convert it back to 3D.

 def RayCast(self, lines, faces):
  visibilityPolygon = []
  for lineWithEnds in lines:
   for r in (0, 1): 
    p1 = lineWithEnds.Point(r)

  # Find the other line at this point

    otherLine = self.FindOtherLineAtPoint(p1, lineWithEnds, lines)
    ray = Line2D(Point2D(0, 0), p1)

  # s is the ray's parameter. We need to know the closest hit to 
  # p0, and possibly (if that is a projecting vertex) the point hit
  # behind that.

    minS = 1
    minFace = lineWithEnds.face
    minBehind = sys.float_info.max
    behindFace = None
    for line1 in lines:
     if line1 != lineWithEnds and line1 != otherLine:
      s, t = ray.Cross(line1)
      if s != None:
       if t >= 0 and t <= 1:
        if s > 0:
         if s < minBehind:
          minBehind = s
          behindFace = line1.face
         if s < minS:
          minS = s
          minFace = line1.face
    classification = 0
    if (abs(minS - 1) < tooShort) and (behindFace != None):
     classification = self.ExtremePoint(p1, ray, lineWithEnds, otherLine, r, lines)
    if classification > 0:
     p2 = ray.Point(minBehind)
     p2.SetFace(behindFace)
     visibilityPolygon.append(p2)
     p3 = ray.Point(minS)
     p3.SetFace(minFace)
     visibilityPolygon.append(p3)
    elif classification == 0:
     p2 = ray.Point(minS)
     p2.SetFace(minFace)
     visibilityPolygon.append(p2)
    else:     
     p2 = ray.Point(minS)
     p2.SetFace(minFace)
     visibilityPolygon.append(p2)
     p3 = ray.Point(minBehind)
     p3.SetFace(behindFace)
     visibilityPolygon.append(p3)
  anglePairs = self.SortByAngle(visibilityPolygon)
  return self.Make3DPolygons(anglePairs, faces) 
   
 
 # Find out if p is in a face of the 3D model

 def PointIsInAFace(self, p, faces):
  v = Part.Vertex(p)
  for face in faces:
   if face.distToShape(v)[0] < tooShort:
    return face
  return None

 # We have a set of points on the visible polygon in 2D, sorted by angle.
 # Add lines between them in 3D that are in actual faces to the output, together.
 # with their face.  Join contiguous lines that share a face.

 def Make3DPolygons(self, anglePairs, faces):

 # Make a list of all the 3D points and which faces (if any) the lines
 # between them lie in.

  allPolygons = []
  pair1 = anglePairs[0] 
  p3D1 = self.vwPoint(pair1[1])
  allPolygons.append((p3D1, None))
  for i in range(1, len(anglePairs)):
   pair2 = anglePairs[i] 
   p3D2 = self.vwPoint(pair2[1])
   halfWayPoint = copy.deepcopy(p3D1)
   halfWayPoint = halfWayPoint.add(p3D2)
   halfWayPoint.multiply(0.5)
   face = self.PointIsInAFace(halfWayPoint, faces)
   allPolygons.append((p3D2, face))
   p3D1 = p3D2

 # Go through and split the list at lines with no faces

   polygon = []
   polygons = []
   pair1 = allPolygons[0]
   polygon.append(pair1)
   for i in range (1, len(allPolygons)):
    pair2 = allPolygons[i]
    if pair2[1] != None:
      polygon.append(pair2)
    else:
     if len(polygon) >= 2:
      polygons.append(polygon)
     polygon = []
     polygon.append(pair2)
    pair1 = pair2
   if len(polygon) >= 2:
    polygons.append(polygon)

 # Now correct the faces of points with faces still set to None

  for polygon in polygons:
   for i in range(1, len(polygon)):
    newPair = (polygon[i-1][0], polygon[i][1])
    polygon[i-1] = newPair

 # Now remove points internal to faces

  for k in range(0, len(polygons)):
   polygon = polygons[k]
   newPolygon = []
   newPolygon.append(polygon[0])
   for i in range(1, len(polygon) - 1):
    if polygon[i-1][1] != polygon[i][1]:
     newPolygon.append(polygon[i])
   newPolygon.append(polygon[len(polygon) - 1])
   polygons[k] = newPolygon

  return polygons

 # Plot the 3D polygons (mainly for checking)

 def PlotPolygons(self, polygons):
  for polygon in polygons:
   wire = []
   for pair in polygon:
    wire.append(pair[0])
   Part.show(Part.makePolygon(wire))

 # We have the visibility polygon, but it is in random order. Sort the points
 # by swept angle from the origin (which is where the light is).

 def SortByAngle(self, visibiltyPolygon):
  anglePairs = []
  for p in visibiltyPolygon:
   line = Line2D(Point2D(0, 0), p)
   angle = math.atan2(line.direction.y, line.direction.x)
   anglePairs.append((angle, p))
  anglePairs.sort(key=lambda pair: pair[0])

 # Remove duplicates (note separate points may share
 # the same angle, so we use inter-point distance to discriminate).

  oldPair = anglePairs[0]
  newAnglePairs = []
  newAnglePairs.append(oldPair)
  for pair in anglePairs:
   diff = pair[1].Sub(oldPair[1])
   d2 = diff.Length2()
   if d2 > tooShort2:
    newAnglePairs.append(pair)
    oldPair = pair
  return newAnglePairs  

 # Turn on the light and make a cross section of a shape, s.
 # Then compute its visibility polygon in the 2D plane of the light
 # sheet (the [v, w] plane) and return that as a FreeCAD object in 3D.
 # (See: https://en.wikipedia.org/wiki/Visibility_polygon)

 def GetVisibilityPolygons(self, s):

  # The origin of coordinates in the 2D light sheet (x0, y0) is the position
  # of the light source in 3D.

  p0 = self.AbsoluteOffset()
  x0 = self.v.dot(p0)
  y0 = self.w.dot(p0)
  lines = []
  visibilityPolygon = []

 # We have to visit each face of object s in turn and compute the line of
 # intersection of the light sheet plane with it because the FreeCAD CrossSection
 # function for whole objects creates internal triangulations in cross-section polygons,
 # which we don't want.

  faces = s.Faces
  for face in faces:

   # Where does the plane cut the face. Note that line may have
   # more than one section if the face has a hole in it.

   faceLines = CrossSection(face, p0, self.u)

   for line in faceLines:
    vertexes = line.Vertexes
    if len(vertexes) != 2:
     print("Line without 2 ends!", len(vertexes))
    else:

    # Find the projection of line into the light sheet plane.
    # The projection of the light source point is the origin
    # of coordinates.

    # We keep track of the face each line came from, though (perhaps surprisingly)
    # that is not much use.

     va = vertexes[0]
     vb = vertexes[1]

     xa = self.v.dot(va.Point) - x0
     ya = self.w.dot(va.Point) - y0
     pa = Point2D(xa, ya, face)

     xb = self.v.dot(vb.Point) - x0
     yb = self.w.dot(vb.Point) - y0
     pb = Point2D(xb, yb, face)

     line = Line2D(pa, pb, face)
     lines.append(line)

  # Cast a ray from the light source through each line end in turn and add what it hits
  # to the visibility polygons.

  return self.RayCast(lines, faces)

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Testing, testing...

a = Part.makeBox(10, 4, 15)
a.translate(Base.Vector(0, 3, 0))
b = Part.makeBox(10, 8, 30)
c =  Part.makeBox(10, 8, 30)
c.translate(Base.Vector(0, 16, 0))
b = b.fuse(c)
b = b.cut(a)
#b = a.cut(b)
Part.show(b)
world = ScannerPart()
twig1 = ScannerPart(offset = Base.Vector(18, 20, 15), parent = world)
twig1.RotateV(1) #math.pi/2)
polygons = twig1.GetVisibilityPolygons(b)
twig1.PlotPolygons(polygons)
Part.show(world.Model())

#world = ScannerPart()
#twig1 = ScannerPart(offset = Base.Vector(8, 20, 25), parent = world)
#twig2 = ScannerPart(offset = Base.Vector(10, -5, 6), parent = world)
#twig3 = ScannerPart(offset = Base.Vector(-10, 10, 30), parent = twig1)
#twig1.RotateU(1)
#a = world.Model()
#Part.show(a)


