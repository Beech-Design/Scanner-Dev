# Beech Design Scanner Simulation
# Adrian Bowyer
# 19 February 2020

import Part, BOPTools, FreeCAD, math, copy
from FreeCAD import Base

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Useful general functions and numbers

# Length in mm considered to be 0

tooShort = 0.001

# There must be an easier way to make the null set...

def Null():
 n1 = Part.makeBox(1, 1, 1)
 n2 = Part.makeBox(1, 1, 1)
 n2.translate(Base.Vector(10, 10, 10))
 return(n1.common(n2))


# Make a cylinder between two points of a given radius

def Cylinder(p0, p1, r):
 p2 = p1.sub(p0)
 length = p2.Length
 if length < 0.001:
  return Null()
 c = Part.makeCylinder(r, length, p0, p2, 360)
 return c

# Make a plane cross section of a solid, s, and return it as a list of wires
# The plane passes through point p0 and has normal n

def CrossSection(s, p0, n):
 nn = copy.deepcopy(n)
 nn.normalize()
 d = nn.dot(p0)
 wires=list()
 for i in s.slice(nn, d):
  wires.append(i)
 comp=Part.Compound(wires)
 return comp

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Small classes for working with 2D vectors

class Point2D:
 def __init__(self, x = 0, y = 0):
  self.x = x
  self.y = y

 def Print(self):
  print(self.x, ',' , self.y)

 # Vector addition and subtraction

 def Add(self, p):
  result = copy.deepcopy(self)
  result.x = result.x + p.x
  result.y = result.y + p.y
  return result

 def Sub(self, p):
  result = copy.deepcopy(self)
  result.x = result.x - p.x
  result.y = result.y - p.y
  return result

 # Squared magnitude

 def Length2(self):
  return self.x*self.x + self.y*self.y

 # Multiplication by a scalar

 def Multiply(self, m):
  result = copy.deepcopy(self)
  result.x = result.x*m
  result.y = result.y*m
  return result  

 # Inner product

 def Dot(self, p):
  return self.x*p.x + self.y*p.y

 # Outer product

 def Cross(self, p):
  return self.x*p.y - self.y*p.x 

# Small class for working with 2D parametric lines

class Line2D:
 def __init__(self, p0 = Point2D(0, 0), p1 = Point2D(0, 0)):
  self.p0 = p0
  self.direction = p1.Sub(p0)
  self.empty = self.Length2() < tooShort2

# The point at parameter value t

 def Point(self, t):
  p = self.direction.Multiply(t)
  return p0.Add(p)

 # Fine the parameter value at which another line crosses me (s) and I cross it (t)

 def Cross(self, otherLine):
  determinant = self.direction.Cross(otherLine.direction)
  if determinant < tooShort2:
   return None, None # Lines parallel
  dp = otherLine.p0.Sub(self.p0)
  s = otherLine.direction.Cross(dp)/determinant
  t = self.direction.Cross(dp)/determinant
  return s, t

 # Squared length

 def Length2(self):
  return self.direction.Length2()

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# The main simulator class - this represents a part of the scanner.  The parts are arranged in a tree.

class ScannerPart:
 def __init__(self, offset = Base.Vector(0, 0, 0), u = Base.Vector(1, 0, 0), v = Base.Vector(0, 1, 0), w = Base.Vector(0, 0, 1), parent = None,\
  lightAngle = -1, uPixels = 0, vPixels = 0, uMM = 0, vMM = 0, focalLength = -1):

  # Offset from the parent in the parent's coordinate system
  # If the parent is None these are absolute cartesian coordinates

  self.offset = offset

  # Local Cartesian coordinates
 
  self.u = u.normalize()
  self.v = v.normalize()
  self.w = w.normalize()

  # If we are a light source (i.e. lightAngle >= 0)

  self.lightAngle = lightAngle

  # If we are a camera (i.e. focalLength >= 0)

  self.uPixels = uPixels
  self.vPixels = vPixels
  self.uMM = uMM
  self.vMM = vMM
  self.focalLength = focalLength

  # Parent and children in the tree

  self.parent = parent
  self.children = []
  if parent is not None:
   parent.children.append(self)

#-----------------

# Compute my absolute offset from the origin recursively

 def AbsoluteOffset(self):
  if self.parent is None:
   return self.offset
  parentUO = copy.deepcopy(self.parent.u)
  parentVO = copy.deepcopy(self.parent.v)
  parentWO = copy.deepcopy(self.parent.w)
  parentUO = parentUO.multiply(self.offset.x)
  parentVO = parentVO.multiply(self.offset.y)
  parentWO = parentWO.multiply(self.offset.z)
  o = parentUO.add(parentVO.add(parentWO))
  return o.add(self.parent.AbsoluteOffset())

# Rotate my coordinates, and the coordinates of all my descendents recursively

 def Rotate(self, r):
  self.u = r.multVec(self.u).normalize()
  self.v = r.multVec(self.v).normalize()
  self.w = r.multVec(self.w).normalize()
  for child in self.children:
   child.Rotate(r)

 # Rotate about the u axis. angle is in radians

 def RotateU(self, angle):
  r = Base.Rotation(self.u, angle*180/math.pi)
  self.Rotate(r)

 # Rotate about the v axis. angle is in radians

 def RotateV(self, angle):
  r = Base.Rotation(self.v, angle*180/math.pi)
  self.Rotate(r)

 # Rotate about the w axis. angle is in radians

 def RotateW(self, angle):
  r = Base.Rotation(self.w, angle*180/math.pi)
  self.Rotate(r)


 # Make a picture of the tree recursively

 def Model(self):
  p1 = self.AbsoluteOffset()
  uc = Part.makeCylinder(0.2, 10, p1, self.u, 360)
  vc = Part.makeCylinder(0.2, 10, p1, self.v, 360)
  wc = Part.makeCylinder(0.2, 10, p1, self.w, 360)
  m = uc.fuse(vc)
  m = m.fuse(wc)
  if self.parent is not None:
   p0 = self.parent.AbsoluteOffset()
  else:
   p0 = Base.Vector(0, 0, 0)
  twig = Cylinder(p0, p1, 0.1)
  m = m.fuse(twig)
  for child in self.children:
   m = m.fuse(child.Model())
  return m

 # Turn on the light and make a cross section of a shape, s.
 # Return the resulting 3D points as 2D polygons in this part's v, w plane

 def VisibilityPolygon(self, s):
  faces = s.Faces
  p0 = self.AbsoluteOffset()
  lines = []
  for face in faces:
   line = CrossSection(face, p0, self.u)
   lines.append(line)
  x0 = self.v.dot(p0)
  y0 = self.w.dot(p0)
  edgeList = []
  for line in lines:
   vertices = line.Vertexes
   edge = []
   for p in vertices:
    edge.append(p.Point)
    x = self.v.dot(p.Point) - x0
    y = self.w.dot(p.Point) - y0
    pp = Point2D(x, y)
    pp.Print()
   if len(edge) >= 2:
    edgeList.append(Part.makePolygon(edge))
  return edgeList

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#a = Part.makeBox(100, 80, 300)
#a.translate(Base.Vector(-40, -20, -100))
b = Part.makeBox(10, 8, 30)
c =  Part.makeBox(10, 8, 30)
c.translate(Base.Vector(0, 16, 0))
b = b.fuse(c)
#b = a.cut(b)
Part.show(b)
world = ScannerPart()
twig1 = ScannerPart(offset = Base.Vector(18, 20, 15), parent = world)
twig1.RotateV(1)
edgeList = twig1.VisibilityPolygon(b)
for edge in edgeList:
 Part.show(edge)
#Part.show(c)
Part.show(world.Model())

#world = ScannerPart()
#twig1 = ScannerPart(offset = Base.Vector(8, 20, 25), parent = world)
#twig2 = ScannerPart(offset = Base.Vector(10, -5, 6), parent = world)
#twig3 = ScannerPart(offset = Base.Vector(-10, 10, 30), parent = twig1)
#twig1.RotateU(1)
#a = world.Model()
#Part.show(a)


