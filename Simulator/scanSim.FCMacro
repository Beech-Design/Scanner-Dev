# Beech Design Scanner Simulation
# Adrian Bowyer
# 19 February 2020

import Part, FreeCAD, math, copy
from FreeCAD import Base

#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Useful general functions

# There must be an easier way to make the null set...

def Null():
 n1 = Part.makeBox(1, 1, 1)
 n2 = Part.makeBox(1, 1, 1)
 n2.translate(Base.Vector(10, 10, 10))
 return(n1.common(n2))


# Make a cylinder between two points of a given radius

def Cylinder(p0, p1, r):
 p2 = p1.sub(p0)
 length = p2.Length
 if length < 0.001:
  return Null()
 c = Part.makeCylinder(r, length, p0, p2, 360)
 return c


#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# The main simulator class - this represents a part of the scanner.  The parts are arranged in a tree.

class ScannerPart:
 def __init__(self, offset = Base.Vector(0, 0, 0), u = Base.Vector(1, 0, 0), v = Base.Vector(0, 1, 0), w = Base.Vector(0, 0, 1), parent = None,\
  lightAngle = -1, uPixels = 0, vPixels = 0, uMM = 0, vMM = 0, focalLength = -1):

  # Offset from the parent in the parent's coordinate system
  # If the parent is None these are absolute cartesian coordinates

  self.offset = offset

  # Local Cartesian coordinates
 
  self.u = u.normalize()
  self.v = v.normalize()
  self.w = w.normalize()

  # If we are a light source (i.e. lightAngle >= 0)

  self.lightAngle = lightAngle

  # If we are a camera (i.e. focalLength >= 0)

  self.uPixels = uPixels
  self.vPixels = vPixels
  self.uMM = uMM
  self.vMM = vMM
  self.focalLength = focalLength

  # Parent and children in the tree

  self.parent = parent
  self.children = []
  if parent is not None:
   parent.children.append(self)

#-----------------

# Compute my absolute offset from the origin recursively

 def AbsoluteOffset(self):
  if self.parent is None:
   return self.offset
  parentUO = copy.deepcopy(self.parent.u)
  parentVO = copy.deepcopy(self.parent.v)
  parentWO = copy.deepcopy(self.parent.w)
  parentUO = parentUO.multiply(self.offset.x)
  parentVO = parentVO.multiply(self.offset.y)
  parentWO = parentWO.multiply(self.offset.z)
  o = parentUO.add(parentVO.add(parentWO))
  return o.add(self.parent.AbsoluteOffset())

# Rotate my coordinates, and the coordinates of all my descendents recursively

 def Rotate(self, r):
  self.u = r.multVec(self.u).normalize()
  self.v = r.multVec(self.v).normalize()
  self.w = r.multVec(self.w).normalize()
  for child in self.children:
   child.Rotate(r)

 # Rotate about the u axis. angle is in radians

 def RotateU(self, angle):
  r = Base.Rotation(self.u, angle*180/math.pi)
  self.Rotate(r)

 # Rotate about the v axis. angle is in radians

 def RotateV(self, angle):
  r = Base.Rotation(self.v, angle*180/math.pi)
  self.Rotate(r)

 # Rotate about the w axis. angle is in radians

 def RotateW(self, angle):
  r = Base.Rotation(self.w, angle*180/math.pi)
  self.Rotate(r)

 # Make a picture of the tree recursively

 def Model(self):
  p1 = self.AbsoluteOffset()
  uc = Part.makeCylinder(0.2, 10, p1, self.u, 360)
  vc = Part.makeCylinder(0.2, 10, p1, self.v, 360)
  wc = Part.makeCylinder(0.2, 10, p1, self.w, 360)
  m = uc.fuse(vc)
  m = m.fuse(wc)
  if self.parent is not None:
   p0 = self.parent.AbsoluteOffset()
  else:
   p0 = Base.Vector(0, 0, 0)
  twig = Cylinder(p0, p1, 0.1)
  m = m.fuse(twig)
  for child in self.children:
   m = m.fuse(child.Model())
  return m

#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

world = ScannerPart()
twig1 = ScannerPart(offset = Base.Vector(8, 20, 25), parent = world)
twig2 = ScannerPart(offset = Base.Vector(10, -5, 6), parent = world)
twig3 = ScannerPart(offset = Base.Vector(-10, 10, 30), parent = twig1)
twig1.RotateU(1)
a = world.Model()
Part.show(a)


